# Oracle Database Changes in CI/CD Workflow

## Introduction

We have a web application developed in Python, running as a micro-service in a Docker container, on OKE cluster using OCI. This application connects to an Oracle Database, and we have seen how CI/CD principles and concepts can be applied to develop this application. We will apply same principles to Oracle Database changes, while altering existing objects, or create new ones, at the same time with application development. Furthermore, we track all database changes, merge them with the code master branch, and make them available to all developers.

There are two methods to capture and track database changes:

1. State based (automated) — Script auto generated by a state comparator containing differences between states (deltas). It still requires a manual step to review the generated change script (highly recommended).

2. Migration based (manual) — Change script created by developer containing changes to apply to the database, in a certain order. The quality of script depends on SQL skills of the application developer.

The tool we use to track, version, and deploy database schema changes is [Liquibase](https://www.liquibase.org/). Liquibase supports a broad range of databases, including Oracle Database. We will use migration based method, because Liquibase is not great at capturing existing changes in an Oracle Database.

Estimated Lab Time: 45 minutes

## **Step 1:** Install Liquibase

1. Access the website, and find the URL for the latest stable release for Linux x64. Deactivate Python virtual environment, and go to oracle's home.

    ````
    deactivate

    cd ~
    ````

2. Download and unzip Liquibase in oracle's home folder on the development machine.

    ````
    wget https://github.com/liquibase/liquibase/releases/download/v3.8.9/liquibase-3.8.9.tar.gz

    mkdir liquibase3.8.9

    tar -xvf liquibase-3.8.9.tar.gz -C liquibase3.8.9/
    ````

3. Add a symbolic link to Liquibase executable command to oracle's binary files.

    ````
    mkdir bin

    ln -s /home/oracle/liquibase3.8.9/liquibase /home/oracle/bin/liquibase
    ````

4. Check Liquibase version.

    ````
    liquibase --version
    Starting Liquibase at Mon, 04 May 2020 15:46:01 GMT (version 3.8.9 #73 built at Mon Apr 06 09:32:58 UTC 2020)
    Liquibase Version: 3.8.9
    ````

5. This is the entire Liquibase installation process. We also need SQL*Plus. It is already installed, with Oracle Instant Client. We just add a symbolic link to the executable in oracle's binary files.

    ````
    ln -s /bin/sqlplus64 /home/oracle/bin/sqlplus
    ````

6. Go back to our working directory.

    ````
    cd orcl-ws-cicd
    ````

7. While working on database only, we don't need the Python virtual environment activated. However, if we plan to work also on Python code at the same time, we need to activate Python virtual environment.

    ````
    . ./orclvenv/bin/activate
    ````

## **Step 2:** Liquibase Basic Practice

1. Before using Liquibase in development, it is a good idea to test it and see how it works. Create a test folder.

    ````
    mkdir liquibase_test

    cd liquibase_test
    ````

2. Create a test user in your database.

    ````
    sqlplus sys/WelCom3#2020_@//[DB_system_host]/[PDB_service_name] as sysdba

    drop user cicd_user cascade;

    CREATE USER cicd_user IDENTIFIED BY WelCom3#2020_ DEFAULT TABLESPACE users TEMPORARY TABLESPACE temp;
    GRANT connect, resource to cicd_user;
    GRANT UNLIMITED TABLESPACE TO cicd_user;
    ````

3. Login as test user.

    ````
    conn cicd_user/WelCom3#2020_@//[DB_system_host]/[PDB_service_name]
    ````

4. Create some objects in test user schema: a table, a trigger, a sequence, and a function. Run these commands one by one.

    ````
    CREATE TABLE feedback (
      id       NUMBER,
      details  VARCHAR2(255),
      received DATE,
      CONSTRAINT feedback_pk PRIMARY KEY (id)
    );

    CREATE OR REPLACE TRIGGER feedback_bi
        before insert on feedback
        for each row
    begin
        :new.received := sysdate;
    end;
    /
    ALTER TRIGGER feedback_bi ENABLE
    /

    CREATE SEQUENCE feedback_seq;

    INSERT INTO feedback (id, details) VALUES (feedback_seq.NEXTVAL, 'Feedback for exercise number ' || feedback_seq.CURRVAL);

    COMMIT;

    CREATE OR REPLACE FUNCTION today_feedback_count RETURN NUMBER AS
      l_count  NUMBER;
    BEGIN
      SELECT COUNT(*)
      INTO   l_count
      FROM   feedback
      WHERE  received >= trunc(sysdate);

      RETURN l_count;
    END;
    /
    ````

5. Exit SQL*Plus.

    ````
    exit;
    ````

6. Create a properties file to store your database connection information.

    ````
    gedit cicd-user.properties
    ````

7. Write the following lines, and save the file before closing.

    ````
    driver : oracle.jdbc.OracleDriver
    classpath : /usr/lib/oracle/18.3/client64/lib/ojdbc8.jar
    url : jdbc:oracle:thin:@//[DB_system_host]/[PDB_service_name]
    username : cicd_user
    password : WelCom3#2020_
    ````

8. This file contains:

- driver - driver class name
- classpath - path for your database driver
- url - Oracle JDBC connect string
- username - database user
- password - database password

    >**Note** : The path for your database driver may be different on deployment environment. In our case, on the container where we deploy our Python microservice, we installed Oracle Instant Client 19.6, and the classpath property is /usr/lib/oracle/19.6/client64/lib/ojdbc8.jar. This is important, as the code we create on the development environment should work on deployment with no changes. This rule applies for all other important packages, e.g. Java. We will not run Liquibase on the Docker container where our microservice is deployed, as we connect to the same database both development and production (deployment) applications.

## **Step 3:** Generate Initial Change-Log

1. Liquibase can generate a change-log based on an existing schema, capturing existing objects. Run the following command to generate the initial change-log.

    ````
    liquibase --defaultsFile="cicd-user.properties" --changeLogFile="initial-changelog.oracle.sql" generateChangeLog
    ````

2. Open the generated initial change-log file.

    ````
    gedit initial-changelog.oracle.sql
    ````

3. This is the content.

    ````
    --liquibase formatted sql

    --changeset oracle:1588064126450-1
    CREATE TABLE FEEDBACK (ID NUMBER NOT NULL, DETAILS VARCHAR2(255 BYTE), RECEIVED date, CONSTRAINT FEEDBACK_PK PRIMARY KEY (ID));

    --changeset oracle:1588064126450-2
    CREATE SEQUENCE FEEDBACK_SEQ START WITH 21 MAXVALUE 9999999999999999999999999999;
    ````

4. Generated change log has only the table and the sequence. The trigger and the function are missing. In conclusion, it is recommended to start from an existing schema and start tracking all changes with Liquibase, and avoid relying on an initial change-log generated by Liquibase to initialize our environment from a master branch. There are better methods to create a database environment from a master branch, like Pluggable Database (PDB) cloning.

## **Step 4:** Use Generic Properties File

1. We can avoid using defaultsFile option for every execution creating a generic properties file present in our current location, called liquibase.properties.

    ````
    gedit liquibase.properties
    ````

2. Contents of the file are the same, with an extra line, that defines a master change-log file. This master change-log contains a list of change-logs, in a specific order, and grouped in change-sets.

    ````
    driver : oracle.jdbc.OracleDriver
    classpath : /usr/lib/oracle/18.3/client64/lib/ojdbc8.jar
    url : jdbc:oracle:thin:@//[DB_system_host]/[PDB_service_name]
    username : cicd_user
    password : WelCom3#2020_
    changeLogFile : cicd-master.xml
    ````

3. A developer needs to write all database changes in change-logs, like the following one:

    ````
    gedit changelog_001.sql
    ````

4. There are multiple formats available. We will use SQL format, it is easy to read and it contains the exact DDL.

    ````
    --liquibase formatted sql
    --changeset valentin:1
    --comment create workshops table
    create table workshops (
        id number generated always as identity,
        name varchar2(80),
        active varchar2(1) default 'N',
        constraint workshops_pk primary key (id)
    );
 
    --rollback drop table workshops purge;
    ````

5. First line is the format. Second one specifies the author, and the order of execution. In the third line, you can add a comment, and the last line defines the rollback command. If you want to apply just an individual change-log, execute this command:

    ````
    liquibase --changeLogFile="changelog_001.sql" update
    ````

6. It overrides changeLogFile parameter specified in liquibase.properties.

## **Step 5:** Query Database Change-Log Table

1. Create the following script to verify the results.

    ````
    gedit query_log.sql
    ````

2. We just need to query a standard table created by Liquibase, named DATABASECHANGELOG.

    ````
    set linesize 120
    column AUTHOR format a10
    column FILENAME format a20
    column TAG format a15
    column COMMENTS format a50

    select AUTHOR, FILENAME, ORDEREXECUTED, TAG, COMMENTS from DATABASECHANGELOG order by 3;

    exit;
    ````

3. Run the verification script.

    ````
    sqlplus cicd_user/WelCom3#2020_@//[DB_system_host]/[PDB_service_name] @query_log

    AUTHOR	   FILENAME		ORDEREXECUTED TAG	      COMMENTS
    ---------- -------------------- ------------- --------------- --------------------------------------------------
    valentin   changelog_001.sql		    1		      create workshops table
    ````

4. Just one change-log recorded. Let's roll back this change-log now. The command rollbackCount <value> rolls back the last <value> change sets.

    ````
    liquibase --changeLogFile="changelog_001.sql" rollbackCount 1
    ````

5. Verify the change-log.

    ````
    sqlplus cicd_user/WelCom3#2020_@//[DB_system_host]/[PDB_service_name] @query_log

    no rows selected
    ````

6. Create a new changelog for a function.

    ````
    gedit changelog_002.sql
    ````

    ````
    --liquibase formatted sql
    --changeset leonard:2
    --comment create active workshops count function
    CREATE OR REPLACE FUNCTION active_workshops_count RETURN NUMBER AS
      l_count  NUMBER;
    BEGIN
      SELECT COUNT(*)
      INTO   l_count
      FROM   workshops
      WHERE  active = 'Y';

      RETURN l_count;
    END;
    /

    --rollback drop function active_workshops_count;
    ````

7. Create another change-log with a new table.

    ````
    gedit changelog_003.sql
    ````

    ````
    --liquibase formatted sql
    --changeset valentin:3
    --comment create sessions table
    create table sessions (
        id number generated always as identity,
        workshop_id number,
        start_date date,
        constraint sessions_pk primary key (id)
    ); 

    --rollback drop table sessions purge;
    ````

## **Step 6:** Use Master Change-Log File

1. We have 3 change-logs for 3 new database objects. These 3 change-logs can be consolidated in the master change-log file. Master change-log can be used also to automate changes in a certain order, making sure the database can be rolled back at any state.

    ````
    gedit cicd-master.xml
    ````

2. All 3 change-logs are part of the same change-set, we call **version_1.1**. Change-sets may have a different author than the change-logs in them.

    ````
    <?xml version="1.0" encoding="UTF-8"?>
    <databaseChangeLog
      xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                          http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.8.xsd">
        <include file="changelog_001.sql"/>
        <include file="changelog_002.sql"/>
        <include file="changelog_003.sql"/>
        <changeSet author="student" id="test_objects">
            <tagDatabase tag="version_1.1"/>
        </changeSet>
    </databaseChangeLog>
    ````

3. We can specify change-logs one by one, or use a path to include them all. We will call them individually so you can understand the order, because when using a path, the order is defined by the name of the files.

    ````
        <includeAll path="/git/my_project/changelogs"/>
    ````

4. Apply all 3 changes using a simple command, as there is no need to specify the properties file nor the specific change-logs. 

    ````
    liquibase update
    ````

5. Verify changes are applied and recored in our database.

    ````
    sqlplus cicd_user/WelCom3#2020_@//[DB_system_host]/[PDB_service_name] @query_log

    AUTHOR	   FILENAME		ORDEREXECUTED TAG	      COMMENTS
    ---------- -------------------- ------------- --------------- --------------------------------------------------
    valentin   changelog_001.sql		    1		      create workshops table
    leonard    changelog_002.sql		    2		      create active workshops count function
    valentin   changelog_003.sql		    3		      create sessions table
    student    cicd-master.xml		    4 version_1.1
    ````

6. When we use rollbackCount command, this includes also the definition of the change-set. 

    ````
    liquibase rollbackCount 1
    ````

7. Now we have only the change-logs applied and recorded, but not the change-set.

    ````
    sqlplus cicd_user/WelCom3#2020_@//[DB_system_host]/[PDB_service_name] @query_log

    AUTHOR	   FILENAME		ORDEREXECUTED TAG	      COMMENTS
    ---------- -------------------- ------------- --------------- --------------------------------------------------
    valentin   changelog_001.sql		    1		      create workshops table
    leonard    changelog_002.sql		    2		      create active workshops count function
    valentin   changelog_003.sql		    3		      create sessions table
    ````

8. Let's rollback last two changes.

    ````
    liquibase rollbackCount 2
    ````

9. Check the results.

    ````
    sqlplus cicd_user/WelCom3#2020_@//[DB_system_host]/[PDB_service_name] @query_log

    AUTHOR	   FILENAME		ORDEREXECUTED TAG	      COMMENTS
    ---------- -------------------- ------------- --------------- --------------------------------------------------
    valentin   changelog_001.sql		    1		      create workshops table
    ````

10. One change-log left. Roll it back to clean the schema.

    ````
    liquibase rollbackCount 1
    ````

11. Group the change-logs in two different change-sets.

    ````
    gedit cicd-master.xml
    ````

    ````
    <?xml version="1.0" encoding="UTF-8"?>
    <databaseChangeLog
      xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                          http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.8.xsd">
        <include file="changelog_001.sql"/>
        <changeSet author="student" id="first_objects">
            <tagDatabase tag="version_1.0"/>
        </changeSet>
        <include file="changelog_002.sql"/>
        <include file="changelog_003.sql"/>
        <changeSet author="student" id="more_objects">
            <tagDatabase tag="version_1.1"/>
        </changeSet>
    </databaseChangeLog>
    ````

12. Apply the master change-log.

    ````
    liquibase update
    ````

13. Verify the changes on the database.

    ````
    sqlplus cicd_user/WelCom3#2020_@//[DB_system_host]/[PDB_service_name] @query_log

    AUTHOR	   FILENAME		ORDEREXECUTED TAG	      COMMENTS
    ---------- -------------------- ------------- --------------- --------------------------------------------------
    valentin   changelog_001.sql		    1		      create workshops table
    student    cicd-master.xml		    2 version_1.0
    leonard    changelog_002.sql		    3		      create active workshops count function
    valentin   changelog_003.sql		    4		      create sessions table
    student    cicd-master.xml		    5 version_1.1
    ````

14. Change-sets allow us to roll back the database to the state it was in when the change-set with that tag was applied.

    ````
    liquibase rollback version_1.0
    ````

15. Check the results.

    ````
    sqlplus cicd_user/WelCom3#2020_@//[DB_system_host]/[PDB_service_name] @query_log

    AUTHOR	   FILENAME		ORDEREXECUTED TAG	      COMMENTS
    ---------- -------------------- ------------- --------------- --------------------------------------------------
    valentin   changelog_001.sql		    1		      create workshops table
    ````

16. In this case, only one change-log remains, as this existed when change-set with tag version_1.0 was applied.

## **Step 7:** Use Liquibase on Development for CI/CD

1. Now we know how Liquibase works, and we can go back to our Python micro-service application. We can make some changes to the database, while tracking and recording them on the master branch using Liquibase.

    ````
    cd ~/orcl-ws-cicd
    ````

2. It is a good practice to group change-logs in folders.

    ````
    mkdir chlg
    ````

3. Create the first change-log for a new table.

    ````
    gedit chlg/changelog_001.sql
    ````

    ````
    --liquibase formatted sql
    --changeset developer:1
    --comment create bonuses table
    CREATE TABLE bonuses (
        employee_id NUMBER(6,0) NOT NULL,
        bonus NUMBER(8,2) DEFAULT 100
    );

    INSERT INTO bonuses(employee_id) (
        SELECT employee_id
        FROM employees
        WHERE salary < 10000
    );
 
    --rollback drop table bonuses;
    ````

4. Some changes may include PL/SQL scripts. It is a good practice to keep your DDL changes and PL/SQL code separated.

    ````
    mkdir plsql
    ````

5. When a change-log does not create a new object, or a roll-back statement cannot be specified, it is good to have a null statement for rollback for Liquibase to clear the records correctly in the DATABASECHANGELOG table.

    ````
    gedit plsql/script_001.sql
    ````

    ````
    --liquibase formatted sql
    --changeset developer:2
    --comment update bonuses table
    MERGE INTO bonuses b USING employees e
        ON ( b.employee_id = e.employee_id) 
        WHEN MATCHED THEN
            UPDATE SET b.bonus = e.salary * .05;

    MERGE INTO bonuses B
      USING (SELECT employee_id, salary, department_id FROM employees
             WHERE department_id = 80) E
      ON (B.employee_id = E.employee_id)
      WHEN MATCHED THEN UPDATE SET B.bonus = B.bonus + E.salary * .01
      WHEN NOT MATCHED THEN INSERT (B.employee_id, B.bonus)
        VALUES (E.employee_id, E.salary * 0.1);

    --rollback select null from dual;
    ````

6. Create a new change-log for a trigger.

    ````
    gedit chlg/changelog_002.sql
    ````

7. For the rollback statement in this case, we can choose to disable the trigger, or drop it.

    ````
    --liquibase formatted sql
    --changeset architect:3
    --comment changes on employees only in business hours
    CREATE OR REPLACE TRIGGER  trg_employees_changes
    before update or insert or delete
    on employees
    for each row
    begin
       if  to_char(sysdate,'hh24') < 6 or to_char(sysdate,'hh24') > 10 then
             raise_application_error(-20234,'No changes allowed before 9 AM and after 6 PM');
       end if;
    end;
    /
    ALTER TRIGGER trg_employees_changes ENABLE
    /
 
    --rollback drop trigger trg_employees_changes;
    ````

8. It is also a good practice to return errors so others can understand the business logic behind the new database objects. In this example we use the function **raise_application_error(error_number, message)**. The error_number is a negative integer with the range from -20999 to -20000. The message is a character string that represents the error message, with a length up to 2048 bytes.

9. Add another change-log for a second trigger.

    ````
    gedit chlg/changelog_003.sql
    ````

    ````
    --liquibase formatted sql
    --changeset architect:4
    --comment cannot decrease employee salary
    CREATE OR REPLACE TRIGGER  trg_employees_relegation
    before update
    on employees
    for each row
    begin
       if  :old.salary > :new.salary then
             raise_application_error(-20123,'Salary can not be decreased');
       end if;
    end;
    /
    ALTER TRIGGER trg_employees_relegation ENABLE
    /
 
    --rollback drop trigger trg_employees_relegation;
    ````

10. One more change-log for a function.

    ````
    gedit chlg/changelog_004.sql
    ````

    ````
    --liquibase formatted sql
    --changeset developer:5
    --comment create function to calculate experience
    CREATE OR REPLACE FUNCTION experience(employee_id NUMBER)
      RETURN VARCHAR2
    IS
      l_years NUMBER;
      l_months NUMBER;
    BEGIN
      select trunc(months_between(sysdate,HIRE_DATE) / 12) into l_years,
             trunc(months_between(sysdate,HIRE_DATE) -
                (trunc(months_between(sysdate,HIRE_DATE) / 12) * 12)) into l_months

      RETURN ('Employee ID ' || employee_id || ' has ' || l_years || ' years and ' || l_months || ' months of experience.' );
    END experience;
    /

    --rollback drop function experience;
    ````

11. Now we create the generic Liquibase properties file.

    ````
    gedit liquibase.properties
    ````

    ````
    driver : oracle.jdbc.OracleDriver
    classpath : /usr/lib/oracle/18.3/client64/lib/ojdbc8.jar
    url : jdbc:oracle:thin:@//[DB_system_host]/[PDB_service_name]
    username : hr
    password : WelCom3#2020_
    changeLogFile : hr-master.xml
    ````

12. Create the change-log master file.

    ````
    gedit hr-master.xml
    ````

13. This change-log master has 4 change-logs, 1 PL/SQL script, organized in 3 change-sets.

    ````
    <?xml version="1.0" encoding="UTF-8"?>
    <databaseChangeLog
      xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                          http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.8.xsd">
        <include file="./chlg/changelog_001.sql" relativeToChangelogFile="true"/>
        <include file="./plsql/script_001.sql" relativeToChangelogFile="true"/>
        <changeSet author="developer" id="bonuses_table">
            <tagDatabase tag="version_1.3"/>
        </changeSet>
        <include file="./chlg/changelog_002.sql" relativeToChangelogFile="true"/>
        <include file="./chlg/changelog_003.sql" relativeToChangelogFile="true"/>
        <changeSet author="architect" id="security_triggers">
            <tagDatabase tag="version_1.4"/>
        </changeSet>
        <include file="./chlg/changelog_004.sql" relativeToChangelogFile="true"/>
        <changeSet author="developer" id="experience_function">
            <tagDatabase tag="version_1.5"/>
        </changeSet>

    </databaseChangeLog>
    ````

14. Create a script to verify the results.

    ````
    gedit query_log.sql
    ````

15. This script will return schema objects, and database change-logs applied.

    ````
    set linesize 120
    column OBJECT_NAME format a30

    select OBJECT_NAME, OBJECT_TYPE from USER_OBJECTS where CREATED >= sysdate - (10/1440) order by 1,2;

    column AUTHOR format a10
    column FILENAME format a22
    column TAG format a15
    column COMMENTS format a50

    select AUTHOR, FILENAME, ORDEREXECUTED, TAG, COMMENTS from DATABASECHANGELOG order by 3;

    exit;
    ````

## **Step 8:** Merge Database Changes

1. Now we can apply all the changes to our database.

    ````
    liquibase update
    ````

2. Once finished, check the results.

    ````
    sqlplus hr/WelCom3#2020_@//[DB_system_host]/[PDB_service_name] @query_log

    OBJECT_NAME		       OBJECT_TYPE
    ------------------------------ -----------------------
    BONUSES 		       TABLE
    DATABASECHANGELOG	       TABLE
    DATABASECHANGELOGLOCK	       TABLE
    EXPERIENCE		       FUNCTION
    PK_DATABASECHANGELOGLOCK       INDEX
    TRG_EMPLOYEES_CHANGES	       TRIGGER
    TRG_EMPLOYEES_RELEGATION       TRIGGER

    7 rows selected.


    AUTHOR	   FILENAME		  ORDEREXECUTED TAG		COMMENTS
    ---------- ---------------------- ------------- --------------- --------------------------------------------------
    developer  chlg/changelog_001.sql	      1 		create bonuses table
    developer  plsql/script_001.sql 	      2 		update bonuses table
    developer  hr-master.xml		      3 version_1.3
    architect  chlg/changelog_002.sql	      4 		changes on employees only in business hours
    architect  chlg/changelog_003.sql	      5 		cannot decrease employee salary
    architect  hr-master.xml		      6 version_1.4
    developer  chlg/changelog_004.sql	      7 		create function to calculate experience
    developer  hr-master.xml		      8 version_1.5

    8 rows selected.
    ````

3. Commit and push all changes to the master branch on code repository.

    ````
    git add chlg/*
    git add plsql/*
    git add liquibase.properties
    git add hr-master.xml
    git add query_log.sql
    git commit -a -m "Add database CI/CD config and change-logs"
    git push
    ````

4. With these files on the repository, all developers will know exactly what changes have been applied to the database, and how to roll back any of these changes. Master change-log file will be used by all to merge their change-logs, and group them in change-sets that will be deployed on production at the end of the sprint.

## Acknowledgements

- **Author** - Valentin Leonard Tabacaru
- **Last Updated By/Date** - Valentin Leonard Tabacaru, Principal Product Manager, DB Product Management, May 2020

## Need Help?
Please submit feedback or ask for help using our [LiveLabs Support Forum](https://community.oracle.com/tech/developers/categories/livelabsdiscussions). Please click the **Log In** button and login using your Oracle Account. Click the **Ask A Question** button to the left to start a *New Discussion* or *Ask a Question*.  Please include your workshop name and lab name.  You can also include screenshots and attach files.  Engage directly with the author of the workshop.

If you do not have an Oracle Account, click [here](https://profile.oracle.com/myprofile/account/create-account.jspx) to create one.

